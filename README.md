### 동시성 제어 방식에 대한 분석 및 보고서


---

동시성 키워드 관련해서는 현재 실무에서 쓰지 않는 기술이기도 하고 
굳이 지금 당장 사용할 일이 없다고 생각해서 따로 공부한적이 없었다.
하지만 언젠가 부터 블로그들에서 동시성 처리 관련하여 다룬 주제들이 자주 보이기 시작했고 
내용들을 조금씩 읽어보니 내가 정말 많은걸 놓치면서 개발을 하고 있었구나를 깨달았다. 
그래서 이번기회에 아주 기초지만 동시성 이슈 관련해서 간단하게 실습해보고 정리를 해봤다. 


### 동시성 이슈란?
- 여러 스레드나 프로세스가 동시에 실행될 때 발생할 수 있는 문제를 의미.
- 주로 공유 자원에 대한 접근이 동시에 이뤄질 때 발생하며, 데이터 일관성, 무결성, 예측가능성을 해칠 수 있다.

### 동시성 이슈는 다음과 같은 상황에 발생할 수 있다
- 경쟁 조건 (Race Condition):
    - 두 개 이상의 스레드가 동시에 같은 자원에 접근하고, 그 자원의 상태를 변경할 때 발생.
    - 이 경우, 최종 결과가 스레드의 실행 순서에 따라 달라질 수 있다.
    - 예를 들어, 두 유저가 동시에 카운터 값을 증가시키면 2가 증가 해야하지만 1만 증가하는 경우
- 데드락 (Deadlock):
    - 두 개 이상의 스레드가 서로가 점유하고 있는 자원을 기다리면서 무한 대기 상태에 빠지는 상황.
    - 예를 들어, 스레드 A가 자원 1을 점유하고 자원 2를 기다리고, 스레드 B가 자원 2를 점유하고 자원 1을 기다리는 경우.
- 라이브락 (Livelock):
    - 스레드가 서로의 상태에 반응하여 계속해서 상태를 변경하지만, 실제로는 진행되지 않는 상황.
    - 예를 들어, 두 스레드가 서로를 피하려고 계속해서 움직이지만, 결국에는 서로의 경로를 막고 있는 경우.
- 스타베이션 (Starvation):
    - 특정 스레드가 자원에 접근할 기회를 얻지 못하고 계속해서 대기하는 상황.
    - 이는 자원 할당 정책이나 우선순위에 따라 발생할 수 있음.


### 싱글 스레드와 멀티 스레드

- 먼저 스레드란?
    - 프로세스가 할당받은 자원을 이용하는 실행의 단위
    - 하나의 프로세스 안에서 다양한 작업을 담당하는 최소 실행 단위
        - ex) 크롬 브라우저(=프로세스)에서 블로그 작성하기(=스레드1) & 유튜브로 음악 듣기(=스레드2)
- 싱글스레드
    - 하나의 프로세스에서 오직 하나의 스레드로 실행.
    - 장점
        - 문맥 교환(context switching) 작업을 요구하지 않음
            - context switching → 현재 작업을 잠시 중단하고 다른 작업을 실행
        - 자원 접근에 대한 동기화를 신경쓰지 않아도 된다.
    - 단점
        - 여러개의 CPU를 활용 못함
        - 연산량이 많은 작업을 하는경우, 그 작업이 완료되어야 다른 작업을 수행할 수 있다.
- 멀티스레드
    - CPU 최대 활용을 위해 프로그램의 둘 이상을 동시에 실행하는 기술
    - 이러한 작업은 context switching을 통해 이뤄지며, context switching이 빠르게 일어나 유저가 봤을땐 프로그램들이 동시에 수행되는 것처럼 보임
    - 장점
        - 경제성 → 프로세스 내 자원들과 메모리를 공유해서 메모리 공간과 시스템 자원소모가 줄어둠
        - 응답성 → 스레드 중 하나가 중단되거나 긴 작업을 수행해도 프로그램의 수행이 계속 되어 사용자에 대한 응답성이 증가한다.
    - 단점
        - 공유하는 자원에 동시에 접근하는 경우, 스레드는 데이터와 힙 영역을 공유해서 어떤 스레드가 다른 스레드에서 사용중인 변수나 자료구조에 접근해 엉뚱한 값을 읽어올 수 있음. 그래서 동기화 필요!
---
### 동시성 제어를 하지 않았을 때
먼저 동시성 제어를 하지 않고 테스트 코드에 동시성 테스트를 위한 환경을 구축하여 테스트를 진행해 봤는데,
역시 기대했던 값과 다른 결과가 나와 테스트가 실패했다. 그럼 어떻게 동시성 제어를 해야할까?

- threadCount: 동시에 실행할 스레드 수.
- executorService: 고정 스레드 풀을 생성하여 동시성 테스트를 위한 스레드 관리.
- latch: 모든 스레드가 작업을 완료할 때까지 대기하기 위한 카운트다운 래치.
- latch.countDown() : 작업이 끝나면 카운트 감소
- latch.await() : 모든 스레드가 작업을 완료할 때까지 대기
![test fail](https://github.com/user-attachments/assets/45f229ac-4530-421f-8bbd-fe902d447d82)

### **동시성 제어 방법**

먼저 동시성 제어를 어떻게 해보는게 좋을까 하고 검색해보니 제일 많이 나온게 
synchronized, ReentrantLock, BlockingQueue + ExcutorService 이 3개였다.
거기에 힌트로 ConcurrentHashMap도 알려주셔서 같이 활용해서 적용해 보았다.

### synchronized
![synchronized](https://github.com/user-attachments/assets/806b41e3-1259-4b4a-a3d9-bb55016f4f6e)

먼저 사용 방법이 제일 간단했던 synchronized를 사용해봤다.
메서드에 synchronized를 붙여서 테스트를 진행하니 정상통과가 되었지만 한계점이 명확했다.
첫번째로는 "어떤 작업"을 동기화 한다고 했을 때 "어떤"을 명확히 정의하지 못하는 경우다.
두번째로 여러 스레드가 동일한 객체나 메서드에 접근한다고 했을 떄 하나의 스레드만 접근하도록 제어해 성능 저하를 일으킬 수 있다는 것이다.
물론 현재 비즈니스 로직은 간단해서 크게 영향은 없겠지만 서비스가 커진다고 했을 때 위의 한계점들이 두드러질 수 있기 때문에 실습만 해보았다. 


### BlockingQueue + ConcurrentHashMap + ExecutorService
![blockingQueue class](https://github.com/user-attachments/assets/df348841-a5dc-4876-905d-2ea0e4d107c8)
![blockingQueue](https://github.com/user-attachments/assets/e73ba697-f53f-4761-a1e8-316f76201f62)

다음은 BlockingQueue + ConcurrentHashMap + ExecutorService(ThreadPoolExecutor)를 사용해봤다.
Queue 컴포넌트를 따로 분리해서 만든다음 주입받아서 사용하는 방법으로 해봤고 실제로 테스트를 진행했을 때도 정상통과가 되었다.
이방법은 나쁘지 않지만 고려할게 좀 있었다.
먼저 요구사항대로면 유저 개수만큼 큐가 동적으로 필요한 거 였고, 다음은 동시에 요청이 들어왔을 때 순차적으로 처리되어야 하지만 
각 요청의 처리를 비동기로 처리해서 동기 처리 고민이였다.
이것 또한 현재 내가 테스트에는 10개 쓰레드로 동시 요청 테스트를 진행했지만 범위가 더 커질수록 성능적 문제가 있다고 판단되어(물론 최적화를 잘해본다면 어떻게든 되겠지만?)
실습만 해보고 넘어갔다.

### ConcurrentHashMap + ReentrantLock
![ReentrantLock](https://github.com/user-attachments/assets/e0cb1c0b-873c-4af7-8a4f-82264cfeb324)

마지막으로 ConcurrentHashMap + ReentrantLock를 사용해보았다.
결론적은 이방법을 사용하여 구현하였는데, 이유는 다음과 같다. 
내가 많이 사용했던 HashMap같은 경우는 구현체에 들어가보면 멀티쓰레드 환경에 안전하지 않다고 되어있다. 
그래서 멀티쓰레드 환경에서 안전한게 데이터를 읽고 쓸 수 있는 ConcurrentHashMap을 사용했다.
ReentrantLock의 경우는 synchronized와 달리 좀 더 유연하고 명시적으로 lock을 사용하여 제어할 수 있고,
또한 공정성(fairness) 옵션을 통해 쓰레드가 lock을 획득하는 순서도 제어할 수 있었다.
그래서 여러 방법 중 이방법이 제일 적합하고 안전하다고 판단되었다.

